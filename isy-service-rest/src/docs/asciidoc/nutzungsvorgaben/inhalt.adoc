// tag::inhalt[]


[[vorgehen]]
== Vorgehen

[[tools]]
=== Tools
Die OpenAPI-Spezifikation wird im yaml-Format erstellt, weil YAML leichter und schneller zu erfassen ist, da die Syntaxregeln von YAML nicht vor allem Einzüge umfasst anstatt Klammern und Anführungszeichen, wie in JSON.
Für die Bearbeitung ist keine IDE erforderlich, ein einfacher Texteditor (z.B. Notepad++) würde ausreichen.
Wir empfehlen den Einsatz eines Swagger-Editors, der sowohl die syntaktische Korrektheit der yaml-Vorgaben, als der OpenAPI-Vorgaben prüft und mögliche Fehler in der Spezifikation in Echtzeit aufdeckt.

Swagger Editor ist ein Tool zum Bearbeiten von OpenAPI-Spezifikationen und unterstützt OpenAPI 3.0.
Swagger Editor validiert die eingegebene Spezifikation und bietet darüber hinaus weitere Funktionalität, wie z.B. Auto-Completion.
Wir empfehlen das entsprechende IntelliJ und Eclipse Plugins dieses Editors (siehe <<SwaggerEditorIntellij>> und <<SwaggerEditorEclipse>>).
Die Verwendung dieser Plugins ist besonders sinnvoll, da sie die Integration der Spezifikation in das Projekt ermöglicht und die Verwaltung mit Version Control erleichtert.

Weitere Informationen zu OpenApi 3.0 (Beschreibung und Vorgaben) finden Sie unter <<SwaggerSpezifikation>>). Bei der Erstellung der Spezifikation sind die Regeln des IsyFact REST-Konzepts (siehe <<RestKonzept>>) zu beachten.

[[mapping-fachlichen-schnittstellen]]
=== Mapping von fachlichen Schnittstellen Beschreibungen auf OpenAPI-Spezifikation
Die Schnittstellenbeschreibung, die im Rahmen der Systemspezifikation erstellt wird, spezifiziert die angebotene(n) Nachbarsystemschnittstelle(n) (NST) aus fachlicher Sicht und gibt keine Auskunft über technische Details.
Für das Erstellen dieser fachlichen Schnittstellenbeschreibung wird die IsyFact-Vorlage <<SystemspezifikationBehoerdenverzeichnis>> verwendet.
Die fachlichen Schnittstellenbeschreibungen nach den Vorgaben der IsyFact enthalten in erster Linie die verwendeten Entitäten sowie Eingabe und Ausgabe Parameter. Ergänzt werden diese durch weitere Spezifika (z.B. Kurzbeschreibung, Synchron/Asynchron, Online/Offline…).
Diese Schnittstellenbeschreibung soll im Rahmen des Systementwurfs technisch als eine OpenAPI-Spezifikation konzipiert und bereitgestellt werden.

Im Folgenden stellen wir ein Vorgehen zum Mappen der fachlichen Schnittstellenbeschreibung auf eine OpenAPI-Spezifikation vor.
Alle Schnittstellen einer Anwendung werden in einer einzigen OpenAPI 3 Spezifikation beschrieben.

Die **Entitäten und die Datentypen** in den fachlichen Schnittstellenbeschreibungen werden mithilfe der OpenAPI Schemaobjekte definiert werden.
Schemaobjekte können Objekte, aber auch Primitive und Arrays sein.
Die Schemaobjekte unterstützen auch Polymorphismus.
Dies ermöglicht auch Vererbung- und Kompositionsrelationen zwischen den Objekten.
Diese Entitäten können so an beliebiger Stelle in der Spezifikation als Referenzobjekt referenziert werden.

Die **Eingabe/Ausgabe Parameter** in den fachlichen Schnittstellenbeschreibungen sind Entitäten oder Datentypen.
Diese Parameter werden zuerst als Schemaobjekte definiert.
Anschließend werden sie als Parameterobjekte oder als Request-Body-Objekte den Schnittstellen zugewiesen, je nachdem wie sie bei der Eingabe/Ausgabe benötigt werden.

[cols="2,2,5,3"]
|===
|IsyFact Schnittstellen-beschreibung|OpenAPI 3 Spezifikation|Beispiel|Bemerkung

|NST_Schnittstelle
|path
a|NST_Mitarbeiter_suchen
[source,yaml]
----
paths:
  /mitarbeiter/sucheNachSuchkriterien:
----

|Es gibt keine bestimmten Vorgaben, um Pfadnamen aus dem Namen der Schnittstelle abzubilden. Es ist jedoch wichtig, einen aussagekräftigen Namen für den Pfad zu wählen, damit er leicht verständlich ist.

|NSE_Entität (Input)
|schema oder type
a|NSE_Mitarbeiter_Suchkriterien:
[source,yaml]
----
NSE_Mitarbeiter_Suchkriterien:
  type: "object"
  properties:
   bundeslandSchluessel:
     $ref: '#/components/schemas/Bundesland'
   ort:
     type: "string"
   trefferanzahl:
     type: "integer"
     format: "int64"
----

oder
[source,yaml]
----
parameters:
  - in: "query"
    name: "bundeslandSchluessel"
    schema:
      $ref: '#/components/schemas/Bundesland'
  - name: "ort"
    in: "query"
    schema:
      type: "string"
  - name: "trefferAnzahl"
    in: "query"
    schema:
      type: "integer"
----

|Es wird empfohlen, die Attribute der Eingabe-Entitäten, die als Abfrageparameter (z. B. Suchkriterien) verwendet werden, als Query Parameters zu definieren. Es ist jedoch möglich, Entitäten mit komplexen Suchkriterien direkt als Entität einzugeben.

Die Eingabe-Entitäten, die im Body verarbeitet werden (z. B. Hinzufügen einer neuen Entität oder Bearbeiten einer vorhandenen Entität), werden als Schema definiert.

|NSE_Entität (Output)
|responses mit schema
a|[source,yaml]
----
responses:
        '200':
          description: successful operation
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Mitarbeiter'
        '405':
          description: "Ungültige Suchkriterien"
----
mit schema für NSE_Mitarbeiter:
[source,yaml]
----
Mitarbeiter:
  type: "object"
  properties:
    id:
      type: "integer"
      format: "int64"
    name:
      type: "string"
    vorname:
      type: "string"
    bundeslandSchluessel:
      $ref: '#/components/schemas/Bundesland'
    telefonnummer:
      type: "string"
----

|

|NSA_Attribut
|property
a|
[source,yaml]
----
id:
  type: "integer"
  format: "int64"
----
|

|DTY_Datentyp (einfach)
|type
a|DTY_Ganzzahl:
[source,yaml]
----
type: "integer"
----
|

|DTY_Datentyp (komplex)
|schema
a|DTY_Bundesland
[source,yaml]
----
    Bundesland:
      type: string
      enum:
        - BW
        - BY
        - BE
        - BB
        - HB
        - HH
        - HE
        - MV
        - NI
        - NW
        - RP
        - SL
        - SN
        - ST
        - SH
        - TH
----
|

|Kurz-
beschreibung
|description
a|
[source,yaml]
----
info:
  description: "Ein Beispiel für das Mapping einer fachlichen Schnittstelle"
----

|

|Offline/Online
|nichts gleichwertiges
|
|

|Synchron/
Asynchron
|nichts gleichwertiges
|
|

|Schnittstellen-
typ
|verb
|get, post, put, delete
|Das passende Verb, um die Art der Transaktion zu beschreiben. (Lese-, Schreib- oder Löschvorgang). Weitere Informationen finden Sie unter <<RestKonzept>>
|===

==== Zusammenfassung des Beispiels (NST_Mitarbeiter_suchen):

[cols="h,1"]
|===
|Kurzbeschreibung
|Diese Schnittstelle bietet Nachbarsystemen die Möglichkeit, Mitarbeiter zu suchen und deren Daten abzufragen. Die Auswahl der Mitarbeiter erfolgt anhand einer Reihe von optionalen Suchkriterien.

|Verwendete Entitätstypen (Input)
|NSE_Mitarbeiter_Suchkriterien

|Verwendete Entitätstypen (Output)
|NSE_Mitarbeiterdaten

|Aufgerufene Anwendungsfälle
|AWF_Mitarbeiter_suchen
|===

===== Eingabeparameter
[cols="h,1"]
|===
|Name
|NSE_Mitarbeiter_Suchkriterien

|Kurzbeschreibung
|Die Kriterien zur Selektion von Mitarbeiter. Alle Attribute dieses Typs sind optional. Nicht befüllte Attribute werden daher nicht in die Suche einbezogen. Es dürfen beliebige Kombinationen von Attributen angegeben werden.
|===

|===
|Name|Datentyp

|NSA_Bundesland_Schlüssel
|DTY_Bundesland

|NSA_Ort
|DTY_Zeichenkette

|NSA_Treffer_Anzahl
|DTY_Ganzzahl
|===

===== Ausgabeparameter
[cols="h,1"]
|===
|Name
|NSE_Mitarbeiterdaten

|Kurzbeschreibung
|Dies ist die Rückgabeentität mit den Daten eines Mitarbeiters.

|===

|===
|Name|Datentyp

|NSA_Name
|DTY_Zeichenkette

|NSA_Vorname
|DTY_Zeichenkette

|NSA_Bundesland_Schlüssel
|DTY_Bundesland

|NSA_Telefonnummer
|DTY_Zeichenkette
|===

===== Das Ergebnis vom Mapping zur OpenAPI 3.0 Spezifikation:

[source,yaml]
----
OpenAPI: 3.0.0
info:
  description: "Ein Beispiel für das Mapping einer fachlichen Schnittstelle"
  version: "1.0.0"
  title: "Beispiel Anwendung"
paths:
  /mitarbeiter/sucheNachSuchkriterien:
    get:
      summary: "Suche Mitarbeiter nach Suchkriterien"
      description: "Diese Schnittstelle bietet Nachbarsystemen die Möglichkeit, Mitarbeiter zu suchen und deren Daten abzufragen. Die Auswahl der Mitarbeiter erfolgt anhand einer Reihe von optionalen Suchkriterien."
      operationId: "sucheMitarbeiterNachSuchkriterien"
      parameters:
        - in: "query"
          name: "bundeslandSchluessel"
          schema:
            $ref: '#/components/schemas/Bundesland'
        - name: "ort"
          in: "query"
          schema:
            type: "string"
        - name: "trefferAnzahl"
          in: "query"
          schema:
            type: "integer"
      responses:
        '200':
          description: successful operation
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Mitarbeiter'
        '405':
          description: "Ungültige Suchkriterien"
components:
  schemas:
    Mitarbeiter:
      type: "object"
      properties:
        id:
          type: "integer"
          format: "int64"
        name:
          type: "string"
        vorname:
          type: "string"
        bundeslandSchluessel:
          $ref: '#/components/schemas/Bundesland'
        telefonnummer:
          type: "string"
    Bundesland:
      type: string
      enum:
        - BW
        - BY
        - BE
        - BB
        - HB
        - HH
        - HE
        - MV
        - NI
        - NW
        - RP
        - SL
        - SN
        - ST
        - SH
        - TH
----

=== Eingabe von weiteren Parametern beim GET und DELETE Requests
Bei manchen Fällen ist es möglich, dass der Server Schreiboperationen ausführt, obwohl wir nur eine GET- oder DELETE-Anfrage gesendet haben.
Ein mögliches Szenario wäre die Protokollierung der Zugriffshistorie, wobei Metadaten wie Nutzername oder Aktenzeichen für die Protokollierung gebraucht werden.
Jedoch werden die GET und DELETE Requests nach dem REST-Konzept (siehe <<RestKonzept>>) ohne Body versendet.
Normalerweise sollen Parameter für Schreiboperationen im Body gesendet werden.
In diesem speziellen Fall wird jedoch entschieden, dass wir die erforderlichen Parameter für Schreiboperationen als Header-Parameter senden.

In OpenAPI 3.0 gibt es die Möglichkeit, die Parametern als Header-Parameter zu definieren.
Dafür verwendet man das Keyword „in: header“.

*Beispiel:* Protokollierung beim NST_Mitarbeiter_suchen.

Anforderung: Es muss immer ein Protokolleintrag erstellt werden, wenn die Schnittstelle für die Mitarbeitersuche aufgerufen wurde.
Für die Protokollierung wird zusätzlich der Nutzername benötigt.

[source,yaml]
----
…
paths:
  /mitarbeiter/sucheNachSuchkriterien:
    get:
      summary: "Suche Mitarbeiter nach Suchkriterien"
      description: "Diese Schnittstelle bietet Nachbarsystemen die Möglichkeit, Mitarbeiter zu suchen und deren Daten abzufragen. Die Auswahl der Mitarbeiter erfolgt anhand einer Reihe von optionalen Suchkriterien."
      operationId: "sucheMitarbeiterNachSuchkriterien"
      parameters:
        - name: "nutzername"
          in: "header"
          schema:
            type: "string"
        - name: "bundeslandSchluessel"
          in: "query"
          schema:
            $ref: '#/components/schemas/Bundesland'
        - name: "ort"
          in: "query"
          schema:
            type: "string"
 …
----

[[Verwendung_von_OpenAPI_Generator]]
== Verwendung von OpenAPI Generator
Es ist möglich, automatisch Code aus einer OpenAPI 3.0-Spezifikation zu generieren. Die IsyFact sieht den Einsatz des OpenAPI-Generators vor.
Für die automatische Generierung muss eine gültige OpenAPI 3.0-Spezifikation als Eingabe bereitgestellt werden.
Der Generator liest diese Spezifikation ein und generiert daraus automatisch eine entsprechende Client- oder Server-Implementierung.
Der Generator unterstützt alle verwendeten REST-Frameworks der IsyFact: Angular (Client), Spring Web Webflux (Client) und Spring MVC (Server).

Wir empfehlen, den Generator über Maven oder direkt über die Konsole zu verwenden. Die Verwendung von maven ist sinnvoll, wenn wir eine neue Anwendung von Grund auf neu erstellen oder die Generierung in einen bestehenden Prozess integrieren möchten, z. B. einen automatischen Prozess zur Generierung von fachlicher Dokumentation.
Aber da wir normalerweise keine neue Anwendung erstellen, sondern neue Schnittstellen zu einer bereits bestehenden Anwendung hinzufügen, ist es normalerweise einfacher, den Generator von der Konsole aus auszuführen und die benötigten Teile aus dem Generat in die Anwendung zu kopieren.

[[die_konsole]]
=== Die Konsole
Über die Konsole ist es erforderlich, die Generator-JAR-Datei von der Website des Generators zu installieren. Der Befehl besteht aus folgenden Teilen:
java -jar <Pfad der Jar-Datei OpenAPI-generator-cli.jar> generate
-i <Pfad der Input-Datei (OpenAPI 3.0 Spezifikation)>
-g <der Name des Generators>
-o <Pfad für den zu erstellenden Code>

Beispiele für die verwendeten Frameworks:

Angular:

[source,shell script]
----
java -jar …/OpenAPI-generator-cli.jar generate
-i …/mitarbeiter_suche.yaml
-g typescript-angular
-o …/mitarbeiter_suche/Angular
----

Spring MVC:

[source,shell script]
----
java -jar …/OpenAPI-generator-cli.jar generate
-i …/mitarbeiter_suche.yaml
-g spring --library spring-mvc
-o …/mitarbeiter_suche/Angular
----

Spring Web Webflux:

[source,shell script]
----
java -jar …/OpenAPI-generator-cli.jar generate
-i …/mitarbeiter_suche.yaml
-g java --library webclient
-o …/mitarbeiter_suche/Angular
----

Danach kann man des erstellten Codes ins Projekt manuell einführen, wobei man die notwendigen Klassen manuell übernimmt.

[[maven]]
=== Maven
Auch in einem bereit vorhandenen Maven-Projekt kann man den OpenAPI Generator aufrufen.
Es ist jedoch wichtig zu beachten, dass der OpenAPI-Generator den Code erstellt, der bereits ein separates Projekt ist.
Daher sollte die Integration des neuen Codes in das bereits bestehende Projekt noch manuell erfolgen.
Ein Beispiel für die Maven-Konfiguration:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.OpenAPItools</groupId>
            <artifactId>OpenAPI-generator-maven-plugin</artifactId>
            <version>5.3.0</version>
            <executions>
                <execution>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <inputSpec>.../mitarbeiter_suche.yaml</inputSpec>
                        <generatorName>spring</generatorName>
                        <library>spring-mvc</library>
                        <generateModelTests>true</generateModelTests>
                        <generateApiTests>true</generateApiTests>
                        <configOptions>
                            <sourceFolder>src/gen/java/main</sourceFolder>
                        </configOptions>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

Die Konfigurationsparameter für den Generator sind die Tags „generatorName“ und der Tag „library“. Die Parameter für die verwendeten Frameworks sind folgende:

|===
||generatorName|library

|Spring MVC
|spring
|spring-mvc

|Spring Web Webflux
|java
|webclient

|Angular
|typescript-angular
| -
|===

Die anderen Parameter für die Basis-Nutzung sind in der folgenden Auflistung beschrieben:

[cols="h,3"]
|===

|inputSpec
|Der Pfad von der eingegebenen OpenAPI 3.0 Spezifikation

|generateModelTests
|Gibt an, ob Tests für Model generiert werden sollen.
Es ist möglich, dass keine Tests generiert werden.
Die Ergebnisse hängen davon ab, ob das verwendete Template diese Funktionalität unterstützt oder nicht.

|generateApiTests
|Gibt an, ob Tests für Api generiert werden sollen.
Es ist möglich, dass keine Tests generiert werden.
Die Ergebnisse hängen davon ab, ob das verwendete Template diese Funktionalität unterstützt oder nicht

|configOptions/
sourceFolder
|Der Pfad für den zu generierenden Code
|===

// end::inhalt[]