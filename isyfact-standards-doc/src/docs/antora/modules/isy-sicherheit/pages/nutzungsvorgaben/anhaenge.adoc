[[einbindung_und_konfiguration]]
= Einbindung und Konfiguration

In diesem Abschnitt wird die Einbindung und Konfiguration von *isy-sicherheit-keycloak* beschrieben.



[[maven-dependency]]
== Maven Dependency

In der pom.xml der Anwendung muss folgende Abhängigkeit ergänzt werden:

[source,xml]
----
<dependency>
  <groupId>de.bund.bva.isyfact</groupId>
  <artifactId>isy-sicherheit-keycloak</artifactId>
</dependency>
----



[[spring-konfiguration]]
== Spring Konfiguration

Die Spring-Konfiguration von isy-sicherheit-keycloak baut auf der Konfiguration von isy-sicherheit auf (siehe <<NutzungsvorgabenSicherheit, Nutzungsvorgaben Sicherheit>>).
Lediglich alle dort beschriebenen CAMS-spezifischen Konfigurationen müssen entfallen.
In IsyFact 2 bringt isy-sicherheit-keycloak eine Autokonfiguration für Spring Boot mit.
Die Bean für den AccessManager für Keycloak wird damit automatisch konfiguriert, wenn keine andere AccessManager-Bean im Kontext vorhanden ist.

Zur Absicherung von Rest-Services in Spring sind weitere Konfigurationen erforderlich.
Insbesondere muss die Spring-Security-Chain korrekt initialisiert werden.
Dies geschieht am einfachsten per Konfiguration nicht in XML sondern im Java-Code.
Hierzu muss in der Anwendung eine Konfigurationsklasse definiert werden, welche von `IsyKeycloakWebSecurityConfigurerAdapter` ableitet:

[source,java]
----
@Configuration
public class BeispielAnwendungSecurityConfig extends IsyKeycloakWebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);

        http.authorizeRequests().anyRequest().authenticated();
    }
}
----

Die `HttpSecurity`-Konfiguration in dem Beispiel oben stellt sicher, dass der Nutzer bei allen Requests authentifiziert ist.
Regeln zur Autorisierung werden hier nicht definiert, da dies in isy-sicherheit über die `Gesichert`-Annotation an den abzusichernden Services erfolgt.

Die Konfigurationsklasse wird als Import in die Hauptklasse in der Anwendung eingebunden:

[source,java]
----
@Configuration
@EnableAutoConfiguration
@Import({ BeispielAnwendungSecurityConfig.class /*, ggf weitere Config*/ })

public class BeispielAnwendungApplication extends SpringBootServletInitializer {
//...
}
----

[[konfigurationsparameter]]
== Konfigurationsparameter

Für die korrekte Anbindung an Keycloak ist die Angabe einiger Konfigurationsparameter notwendig.
Die in den <<NutzungsvorgabenSicherheit, Nutzungsvorgaben Sicherheit>> beschriebenen Parameter für CAMS (`sic.camsagent.*` und `cams.*`) sind nicht mehr relevant.

Der Präfix sämtlicher Konfigurationsparameter `isy.sicherheit.keycloak` wird zur Vereinfachung in der Liste unten weggelassen.

Einige Konfigurationsparameter sind mit einem Zähler versehen.
Diese beinhalten mit `instances[0]` und können für mehr als eine Sicherheitsdomäne und/oder Keycloak-Installation definiert werden.
Die Parameter für eine zweite Konfiguration müssen mit `instances[1]` ergänzt werden.
Weitere Konfigurationen werden demzufolge mit Parametern konfiguriert, die mit `instances[2]`, `instances[3]`, etc. enthalten.
Dies ist dann sinnvoll, wenn eine Anwendung nicht nur Access-Tokens einer Sicherheitsdomäne in einer Keycloak-Installation akzeptieren soll, sondern verschiedene.
Ein Beispiel für eine Anwendung mit zwei Realms ist eine Geschäftsanwendung,
welche einen Realm zur Prüfung der Tokens benötigt mit denen es aus dem Portal heraus über den Proxy aufgerufen wird und
einen zweiten Realm zur Initiierung der Authentifizierung eines Timer-Tasks oder Batch.

:desc-table-parameter: Konfigurationsparameter
[id="table-parameter",reftext="Konfigurationsparameter"]
.{desc-table-parameter}
[cols="3m,2m,2m,8",options="header"]
|===
|Parameter |Wertebereich |Default |Beschreibung
4+|*Parameter pro Sicherheitsdomäne und/oder Keycloak-Installation*
|instances[0].realm |String |_keiner_ |Der Realm bei Keycloak (=Sicherheitsdomäne)
|instances[0].realmKey |String |_keiner_ |Der Public-Key zur Überprüfung der Token-Signatur.
    Der Wert hier kann der Realm-Konfiguration in Keycloak entnommen werden.
    Wird i.d.R. nicht gesetzt, damit der Key automatisch von Keycloak bezogen wird.
|instances[0].auth-server-url |String |_keiner_ |Link auf die betreffende Keycloak-Instanz (Beispiel: http://keycloak:8080/auth).
    Der Link dient dazu die Keycloak-Instanzen zu unterscheiden und wird zur Kommunikation dieser Anwendung mit Keycloak benötigt;
    beispielsweise zur Abfrage des Public-Key zur Überprüfung der Token-Signatur.
    Der Link muss mit dem Aussteller des Tokens übereinstimmen.
|instances[0].ext-auth-server-url |String |_keiner_ |Alternativer Link auf die betreffende Keycloak-Instanz (Beispiel: http://proxy/keycloak/auth).
    Der Link wird nur zur Token-Prüfung verwendet, es werden keine Anfragen über die URL gesendet.
    Tokens bei denen dieser Link als Aussteller im Token steht, werden auch akzeptiert.
|instances[0].default-instance |boolean |false |Markiert eine Keycloak-Instanz als Default.
    Falls keine Instanz explizit als Default markiert ist, wird die erste Instanz genommen.
    Die Default-Instanz ist relevant, wenn die Anwendung eine Authentifizierung bei Keycloak initiieren will.
|instances[0].bearer-only |boolean |true |Bearer-only Anwendungen können nur Tokens prüfen, aber selbst keine Authentifizierung bei Keycloak initiieren.
    In der Regel ist dies bei GUI-Anwendungen der Fall, bei denen das Token durch einen vorgeschalteten Apache ermittelt wird.
|instances[0].resource |String |bearer-only |Der Name des Clients, der für die Authentifizierung bei Keycloak verwendet wird.
    Für bearer-only Anwendungen ist keine Konfiguration notwendig.
|instances[0].credentials-secret |String |_keiner_ |Passwort mit dem sich die Anwendung / der Client bei Keycloak authentifiziert.
    Für bearer-only Anwendungen ist keine Konfiguration notwendig.
|instances[0].enable-basic-auth |boolean |false | Aktivierung von HTTP Basic-Authentication.
    Funktioniert nur, wenn der Keycloak Client auch entsprechend konfiguriert ist.
    Wird bereits auf einen sinnvollen Standardwert gesetzt.
    Anpassungen sind i.d.R. nicht notwendig.
|instances[0].public-client |boolean |false |Bei Public-Clients wird kein Client-Secret benötigt, um eine Authentifizierung bei Keycloak zu initiieren.
    Funktioniert nur, wenn der Keycloak Client auch entsprechend konfiguriert ist.
    Wird bereits auf einen sinnvollen Standardwert gesetzt.
    Anpassungen sind i.d.R. nicht notwendig.
|instances[0].ssl-required |String |external |Definiert, wann eine SSL Verbindung verpflichtend ist.
    Wird bereits auf einen sinnvollen Standardwert gesetzt.
    Anpassungen sind i.d.R. nicht notwendig.
|instances[0].principal-attribute |String |sub |Definiert, welches Token-Attribut als User-Name genutzt wird.



4+|*Allgemeine Parameter*:
|cert-header-name |String |x-client-cert |
Als zusätzliche Sicherheitsmaßnahme ist zur Authentifizierung in Keycloak ein Behördenkennzeichen erforderlich, welches zu dem Behördenkennzeichen passen muss, dass im Nutzerprofil hinterlegt ist.
Das Behördenkennzeichen wird von Keycloak aus dem Zertifikat ausgelesen.
Der Name des HTTP-Headers, der das Zertifikat enthält ist konfigurierbar.
|cert-dn-header-name |String |x-client-cert-dn |
Alternativ kann statt des Zertifikats auch nur der DN aus dem Zertifikat an Keycloak weitergeleitet werden.
Hierfür wird ein anderer HTTP-Header verwendet.
|bhknz-header-name |String |x-client-cert-bhknz |
Alternativ kann statt des Zertifikats oder DN auch nur das Behördenkennzeichen an Keycloak weitergeleitet werden.
Hierfür wird ein anderer HTTP-Header verwendet.
Dies wird zum Test, aber auch in Produktion beispielsweise bei Batches verwendet.
|standard-zertifikat-ou |String |AZRVISAPORTAL |Der Wert wird verwendet, wenn ein Aufruf mit BHKNZ jedoch ohne Zertifikat-OU eingeht.
|korrelations-id-header-name |String |correlationid |Der Name des Korrelations-ID-Headers in Anfragen an Keycloak.
|bhknz-attribute-name |String |bhknz |Der Attributname der Behördenkennzeichen in den Userdaten in den Antworten von Keycloak.
|interne-kennung-attribute-name |String |internekennung |Der Name des Claims im Token, aus dem die interneKennung für den Aufrufkontext entnommen wird
|===


[[authentifizierung]]
= Authentifizierung

Die Authentifizierung erfolgt über Keycloak.
Keycloak greift hierbei auf die Benutzerdaten im Benutzerverzeichnis zu.
Nach erfolgreicher Authentifizierung stellt Keycloak ein Access-Token aus, welches die benötigten Informationen zum angemeldeten Nutzer enthält.
Dies sind beispielsweise die Rollen des Nutzers, das Kennzeichen der Behörde, welcher er zugeordnet ist, sowie der Nutzername.



[[authentifizierung_in_der_gui]]
== Authentifizierung in der GUI

Die Authentifizierung in der GUI erfolgt über ein Modul im Apache, welches prüft, ob bereits eine gültige Session vorhanden ist.
Falls nein, wird der Nutzer auf die Login-Seite von Keycloak umgeleitet und kann dort seine Credentials eingeben.
Wenn die Authentifizierung bei Keycloak erfolgreich war, liefert Keycloak ein Access-Token zurück.
Dies wird in der Session gespeichert und bei jedem Request an die nachgelagerten Anwendungen über einen HTTP-Header mitgeschickt.

Im der aufgerufenen Anwendung wird durch isy-sicherheit-keycloak geprüft, ob das Token gültig ist.
Hierzu wird der Public-Key des Realm in Keycloak benötigt.
Dieser wird automatisch (über einen öffentlichen Rest-Endpunkt) bei Keycloak abgefragt und in einem Cache in der Anwendung vorgehalten.
Wenn die Token-Prüfung erfolgreich war, werden die Daten aus dem Token in einem `AufrufKontext` im `AufrufKontextVerwalter` gespeichert.
Zusätzlich werden die Daten auch im Spring-Security-Context gespeichert.
Dies ermöglicht Autorisierungsprüfungen sowohl über die `Gesichert`-Annotation aus isy-sicherheit,
als auch über die entsprechenden Mechanismen in Spring-Security, beispielsweise die `Secured`-Annotation.



[[authentifizierung_innerhalb_einer_anwendung]]
== Authentifizierung innerhalb einer Anwendung

Zur Authentifizierung innerhalb einer Anwendung muss ein `AufrufKontext` oder `ZertifikatInfoAufrufKontext` erzeugt werden, in dem Kennung, Passwort und Behördenkennzeichen oder Zertifikat gefüllt sind.
Über die Komponente `Sicherheit` kann dann die Authentifizierung bei Keycloak angestoßen werden.
Der Aufruf an Keycloak erfolgt dabei über den `KeycloakAccessManager`.
Wenn die Authentifizierung bei Keycloak erfolgreich war, liefert Keycloak ein Access-Token zurück.
Die Daten aus dem Token werden in einem `AufrufKontext` im `AufrufKontextVerwalter` gespeichert.
Zusätzlich werden die Daten auch im Spring-Security-Context gespeichert.



[[autorisierung]]
= Autorisierung

[[autorisierung_eines_rest_service]]
== Autorisierung eines REST Service

Bei REST Services wird erwartet, dass der Aufrufer ein gültiges Access-Token mitschickt.
Das Token wird als Bearer-Token im Authorization Header des Http-Requests erwartet.
Hieraus erzeugt isy-sicherheit-keycloak (wie oben beschrieben) einen `AufrufKontext`.
Die Autorisierungsprüfung erfolgt dann, entsprechend dem Konzept von isy-sicherheit, über die `Gesichert`-Annotation an der Service-Implementierung.



[[autorisierung_eines_httpinvoker_service]]
== Autorisierung eines HttpInvoker Service

Bei HttpInvoker Services wird erwartet, dass der `AufrufKontext` als erster Parameter mitgesendet wird.
Dieser wird dann zur Autorisierungsprüfung herangezogen.

Aktuell gibt es noch keine Festlegungen zur Nutzung von Tokens auch bei HttpInvoker.



[[testunterstuetzung]]
= Testunterstützung

In diesem Abschnitt wird *isy-sicherheit-keycloak-test* beschrieben.

Isy-sicherheit-test enthält Hilfsklassen zum Erstellen von (automatisierten) Tests, in welchen isy-sicherheit-keycloak benötigt wird.
Das Projekt enthält eine Mock-Implementierung von Keycloak.
Zur Simulation des REST-Services wird WireMock verwendet.

Isy-sicherheit-test wird auch in den Unit-Tests des Projekts isy-sicherheit-keycloak verwendet.

Das folgende Beispiel zeigt die einfache Initialisierung eines Mocks für Keycloak, mit genau einem Nutzer mit genau einer Rolle:

[source,java]
----
EmbeddedKeycloakMock embeddedKeycloak = new EmbeddedKeycloakMock("localhost", 9095, "testRealm", new RsaKeyGenerator());
embeddedKeycloak.addUser("testUser", "testPwd", "testBhknz", Collections.singleton("testRolle"));
----
